
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="text/javascript" http-equiv="content-script-type">
<title>org.dsource.descent.unittests.flute</title>
<link rel="stylesheet" type="text/css" href="candydoc/style.css">
<!--[if lt IE 7]><link rel="stylesheet" type="text/css" href="candydoc/ie56hack.css"><![endif]-->
<script language="JavaScript" src="candydoc/util.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/tree.js" type="text/javascript"></script>
<script language="JavaScript" src="candydoc/explorer.js" type="text/javascript"></script>
</head><body>
<div id="tabarea"></div><div id="explorerclient"></div>
<div id="content"><script>explorer.initialize("org.dsource.descent.unittests.flute");</script>
	<table class="content">
		<tr><td id="docbody"><h1>org.dsource.descent.unittests.flute</h1><!-- Generated by Ddoc from ..\src\org\dsource\descent\unittests\flute.d -->
$(DDOC_SECTIONS 
<b>Summary:</b><br>
Flute is an interactive tool for executing D unit tests. It is based on Thomas
 Kuehne's <a href="http://flectioned.kuehne.cn/#unittest">UnittestWalker</a>. Like
 UnittestWalker, it requires <a href="http://flectioned.kuehne.cn">Flectioned</a> to work
 correctly, and right now is only compatible with D version 1.x. It extends
 UnittestWalker by providing an interactive (stdin/stdout-based) way to find and
 execute unit tests.
<br><br>

 However, while 
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

 can be used interactively, it is mainly
 designed to be extended by automated testing tools, such as
 <a href="http://www.dsource.org/projects/descent">descent.unittest</a> or build tools,
 and hopefully be integrated into a project like CruiseControl, etc. It also allows
 for execution of tests one at a time or execution of selected tests, which makes
 test automation more versatile (especially if running all the tests takes a long
 time.) To be truly used effectively, 
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

 needs to be paired with a code analysis
 or other tool to identify/name unittests which is then executed by the fluted
 application. If all you want is to run all the unittests in the project,
 UnittestWalker is a better bet.

<br><br>
<b>Usage:</b><br>
Flute must be statically linked against an application, just like UnittestWalker.
 To do so, place it at the end of the build command, i.e. "<b>dmd -unittest
 <i>&lt;your source code&gt;</i> flectioned.d 
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

.d</b>" or "<b>gdmd -fall-sources
  -unittest <i>&lt;your source code&gt;</i> flectioned.d 
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

.d</b>". To run, simply start
  the generated executable. Note that your actual application cannot be started
  if you use 
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

.

<br><br>
$(DDOC_SECTION <b>Definitions:</b><br>
<ul>   <li>A "line" is any number of ASCII characters (that may contain CR, LF or a
        CRLF pair, although they will only do so if the host program uses
        them, for example in the text for an assert() statement) followed by a
        system-specific line terminator.</li>

</ul>
$(DDOC_SECTION <b>Interface:</b><br>
The interface is well-defined. That is, while it is designed to be human-
 readable, it is fully specified and can hopefully be processed by automated
 testing tools. The interface may change between versions.
<br><br>

 When the program is executed, one or more lines containing version information
 will be displayed. For this version, the version line will be "<b>
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

 0.1</b>".
 The program will then enter a loop where it will await input from stdin,
 process the given command, and await futher input. The commands are: <ul>    <li><b>r <i>test signature</i></b> -
        (An r, followed by a space, followed by the signature or name
        of a test). Will run the specified test and print the
        results to stdout. See "test signature specification" for the
        specification of what the test signatures will look like. See "test
        result specification" for a specification of what the results will
        look like. See "Test Naming" for the specification of how test names
        are handled.</li>
     <li><b>l</b> -
        (Prints a list of all the tests in the project. One test specification
        will appear per line. Named tests will appear first, followed by unnamed
        tests. Named tests will appear as their fully qualified test name.
        Unnamed tests will simply appear with their signature on a line. The
        order in which tests are printed is the alphabetical order of their
        signatures, and lexical order for unittests within the same scope.)
     <li><b>a</b> -
        (An a alone on a line). Will execute all the tests in the
        application. For each test, it will write a line containing "Running: "
        (without the quotes), then the signature of the test being run on a
        line. Then it will write the results of a test. After running all the
        tests, a line containing "SUMMARY: " will be written, then all of the following
        lines&#58 "PASSED: #/#", "FAILED: #/#", "ERROR: #/#", each preceded by
        three spaces, where the first number sign in a line is replaced by the number
        of tests that met that condition, and the second in each line is replaced
        by the total number of executed tests. Any tests that caused an internal
        error will not be reported in any of the three categories, nor will they be
        included in the total. There will be a blank line between each test.</li>
     <li><b>p</b> -
        (A p alone on a line). Exist 
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

 interface and runs the application.</li>
     <li><b>x</b> -
        (An x alone on a line). Will exit the program.</li></li>

</ul>
<b>Test Signature Specification:</b><br>
A test signature is a way to uniquely identify a unittest in an application.
 Although linker symbols do this, they are not available to a code-analysis
 front-end. Thus, a signature form is needed that can be generated by code
 analysis, easily translated to and from linker symbols, and is (generally) human-
 readable.
<br><br>

 A test signature consists of the fully-qualified name of the test's location,
 followed by a period, followed by the number of the test in that location in the
 lexical order the test appears (0-based). For example if you have:
<pre class="d_code"> <font color=blue>module</font> foo.bar;

 <font color=blue>unittest</font> { <font color=green>/+ Test 1 +/</font> }

 <font color=blue>class</font> Baz {
     <font color=blue>unittest</font> { <font color=green>/+ Test 2 +/</font> }
 }

 <font color=blue>unittest</font> { <font color=green>/+ Test 3 +/</font> }
</pre>
 there will be three tests: <ul>   <li>Test 1 is <b>foo.bar.0</b></li>
    <li>Test 2 is <b>foo.bar.Baz.0</b></li>
    <li>Test 3 is <b>foo.bar.1</b></li></ul>

<br><br>
<b>Test Names:</b><br>
Instead of using signatures, names can be used to refer to tests as well. Since
 signatures are often long and difficult to type, this is often the preferred
 method. To add a signature to a test, import org.dsource.descent.unittests.naming
 and insert use "mixin(test_name(<i>test name</i>));" somewhere in your test body.
 For example:
<pre class="d_code"> <font color=blue>module</font> bacon.eggs;
 <font color=blue>import</font> org.dsource.descent.unittests.naming;

 <font color=blue>class</font> Sausage {
     <font color=blue>unittest</font> {
         <font color=blue>mixin</font>(test_name(<font color=red>"spam"</font>));
         <font color=green>// ...
</font>     }
 }
</pre>

 To refer to a named test, you may either use the signature generated for it or use
 the test's name. The test's name can either be fully qualified or, if unambiguous,
 can appear with a colon preceding it. If there's more than one test in the
 application with the unqualified name, an error will result.
 In the example above, the test can be referred to as any of: <ul>   <li>bacon.eggs.Sausage.0</li>
    <li>bacon.eggs.Sausage.spam</li>
    <li>:spam</li></ul>

<br><br>
<b>Test Result Specification:</b><br>
After a test is run, there are four possible results: <ul>   <li>The test could succeed, in which case a line containing "<b>PASSED</b>" will be
       printed on a line.</li>
    <li>The test could fail an assertion. A line containing "<b>FAILED</b>" will be printed,
       followed by the stack trace of the exception.</li>
    <li>The test could throw an exception. A line containing "<b>ERROR</b>" will be printed,
       followed by the stack trace of the exception. The main rationale for
       treating test failures differently than exceptions is to allow automated
       tools to track failures vs. error conditions. However, the tool can't
       differentiate between assertions failed in the tests and assertions failed
       in the main program body, so a "<b>FAILED</b>" message can mean either.</li>
    <li>An internal error could occur with the test runner (for example, the test is
       not found). In this case, a human-readable message that does not begin with
       "<b>PASSED</b>", "<b>FAILED</b>" or "<b>ERROR</b>" will be printed on a single line.
       If the test is not found, the message will be "<b>Test <i>test signature</i> not
       found</b>", where "test signature" will be replaced with the signature of the test.
       Other error messages may appear and are unspecified.</li></ul>

<br><br>
<b>Stack Trace Specification:</b><br>
The test runner has support for Flectioned's TracedException, but will work
 correctly even if the thrown exception is not a TracedException. The stack trace
 will begin with a line containing the name of the thrown exception. If the
 exception has a message, this will be followed by ": " and then the exception
 message.
<br><br>

 If the exception is an assertion failure (AssertError in Phobos, AssertException
 in Tango), the line will instead be "<b>Assertion failed in <i>&lt;filename&gt;</i>
 at line <i>&lt;line&gt;</i></b>" followed by ": " and a message if there is one. The
 rationale behind rewriting this exception is to smooth over differences between
 Tango and Phobos, which report their assert errors differently.
<br><br>

 If the exception is a subclass of TracedException, this will be followed by the
 actual stack trace of the exception. Each line of the stack trace will begin with
 three spaces, which will allow stack traces to be easily visually parsed
 from the surrounding information and dealt with in automated tools. The stack
 trace differs from the standard Flectioned stack trace for a TracedException to
 ease processing.
<br><br>

 Each line of the stack trace represents a stack frame that was executing when the
 exception was thrown. The stack frames will be reported in reverse order (the
 "unwinding" of the stack). TODO - finish this.

<br><br>
<b>Limitations:</b><br>
<ul>   <li>No Unicode/internationalization support (planned)</li>
    <li>Untested in low memory situations
    <li>Only tested with D 1.x (future versions will support D2)</li>
    <li>No test suites/categorization (will possibly be in a future version, but
         the Descent front-end should support this when it gets released.)</li>
    <li>Requires Flectioned (not likely to change)</li></li>

</ul>
<font color=red>BUGS:</font><br>
If a class is inside a function, unittests in that class won't work. Keep this in
 mind when generating signatures in code analysis tools. For example, if you have:
<pre class="d_code"> <font color=blue>module</font> foo.bar;

 <font color=blue>unittest</font> { <font color=green>/+ Test 1 +/</font> }

 <font color=blue>void</font> baz() {
     <font color=blue>class</font> Quux {
         <font color=blue>unittest</font> { <font color=green>/+ Test 2 +/</font> }
     }
 }

 <font color=blue>unittest</font> { <font color=green>/+ Test 3 +/</font> }
</pre>
 there will be two tests: <ul>   <li>Test 1 is <b>foo.bar.0</b></li>
    <li>Test 3 is <b>foo.bar.1</b></li></ul>
 The middle test is inaccessible via 
<span class="currsymbol">flute</span>
<script>explorer.outline.addDecl('flute');</script>

. This applies to unittests in anonymous
 classes, too. I hope to fix this in a future version.

<br><br>
<b>Authors:</b><br>
Robert Fraser (fraserofthenight@gmail.com)

<br><br>
<b>Version:</b><br>
Almost 0.1

<br><br>
<b>License:</b><br>
Copyright (c) 2007 Robert Fraser (fraserofthenight@gmail.com)


<br><br>

 All rights reserved. This program and the accompanying materials
 are made available under the terms of the Eclipse Public License v1.0
 which accompanies this distribution, and is available at
<br><br>
<b>http:</b><br>
//www.eclipse.org/legal/epl-v10.html
 
<br><br>
<br><br>

<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">enum 
<span class="currsymbol">ResultType</span>
<script>explorer.outline.addDecl('ResultType');</script>

;
</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The result of running a test
 
<br><br>


<script>explorer.outline.incSymbolLevel();</script>
<dl>
<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">
<span class="currsymbol">PASSED</span>
<script>explorer.outline.addDecl('PASSED');</script>

</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The test passed succesfully
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">
<span class="currsymbol">FAILED</span>
<script>explorer.outline.addDecl('FAILED');</script>

</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The test failed an assertion
<br><br>

</dd>

<script>explorer.outline.writeEnabled = true;</script>
<dt><span class="decl">
<span class="currsymbol">ERROR</span>
<script>explorer.outline.addDecl('ERROR');</script>

</span></dt>
<script>explorer.outline.writeEnabled = false;</script>


<dd>The test threw another type of exception
<br><br>

</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</dd>
</dl>
<script>explorer.outline.decSymbolLevel();</script>


</td></tr>
		<tr><td id="docfooter">
			Page was generated with
			<img src="candydoc/img/candydoc.gif" style="vertical-align:middle; position:relative; top:-1px">
			on Sat Dec  1 19:12:58 2007

		</td></tr>
	</table>
</div>
<script>
	explorer.packageExplorer.addModule("org.source.descent.unittests.flute");</script>
</body></html>


